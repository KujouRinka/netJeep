#ifndef NETCAT_CONNECTION_H
#define NETCAT_CONNECTION_H

#include <asio.hpp>

#include "net.h"
#include "types.h"
#include "buffer.h"
#include "proxy_interface.h"

using namespace asio;

/**
 * @brief BaseConn defines all interfaces a connection may use
 */
class BaseConn {
public:
    virtual void start() = 0;

    virtual void inRead(conn_p holder) = 0;
    virtual void inWrite(conn_p holder) = 0;
    virtual void outRead(conn_p holder) = 0;
    virtual void outWrite(conn_p holder) = 0;

    virtual Buffer *inToOutBuf() = 0;
    virtual Buffer *outToInBuf() = 0;
    virtual io_context &getCtx() = 0;
    virtual NetAddress &remote() = 0;

    virtual void closeMe(CloseType type) = 0;
    virtual void closeOtherSide(CloseType type) = 0;
    virtual void closeAll() = 0;

    virtual long long id() = 0;
    virtual ConnHandler *&connHandler() = 0;
    virtual BaseConn *&holder() = 0;

    virtual void dial(conn_p base) = 0;
};

/**
 * @brief InConn does thing related to in socket
 *
 * InConn is generated by Authenticator and do handshaking.
 * It parse remote address and after that generated Dialer
 * for remote connecting. It also do data transfer after
 * remote connection established.
 *
 */
class InConn :
        public BaseConn,
        public enable_shared_from_this<InConn> {
public:
    InConn(io_context &ctx, ConnHandler *h, long long id)
            : _ctx(ctx), _conn_handler(h), _id(id), _out_holder(nullptr),
              _in_to_out_buf(new Buffer), _out_to_in_buf(new Buffer) {}
    virtual ~InConn();

    void start() override;

    void inRead(conn_p holder) override = 0;
    void inWrite(conn_p holder) override = 0;
    void outRead(conn_p holder) override;
    void outWrite(conn_p holder) override;

    Buffer *inToOutBuf() override;
    Buffer *outToInBuf() override;
    io_context &getCtx() override;
    NetAddress &remote() override;

    void closeMe(CloseType type) override = 0;
    void closeOtherSide(CloseType type) override;
    void closeAll() override;

    long long id() override;
    ConnHandler *&connHandler() override;
    BaseConn *&holder() override;

    void dial(conn_p base) override;

protected:
    io_context &_ctx;
    long long _id;

    BaseConn *_out_holder;

    Buffer *_in_to_out_buf;
    Buffer *_out_to_in_buf;

    ConnHandler *_conn_handler;

    NetAddress _remote;
};

/**
 * @brief OutConn does things related to out socket
 *
 * OutConn picks route by remote address the InConn parsed.
 * Then passes real connecting job to its ConnHandler. After that
 * it does data transfer cooperating with InConn.
 *
 */
class OutConn :
        public BaseConn,
        public enable_shared_from_this<OutConn> {
public:
    OutConn(conn_p p) : _ctx(p->getCtx()), _in_holder(p.get()) {}
    virtual ~OutConn() = default;

    void start() override;

    void inRead(conn_p holder) override;
    void inWrite(conn_p holder) override;
    void outRead(conn_p holder) override = 0;
    void outWrite(conn_p holder) override = 0;

    Buffer *inToOutBuf() override;
    Buffer *outToInBuf() override;
    io_context &getCtx() override;
    NetAddress &remote() override;

    void closeMe(CloseType type) override = 0;
    void closeOtherSide(CloseType type) override;
    void closeAll() override;

    long long id() override;
    ConnHandler *&connHandler() override;
    BaseConn *&holder() override;

    // dial does route pick and connect
    void dial(conn_p in_holder) override = 0;

protected:
    io_context &_ctx;
    BaseConn *_in_holder;

    ConnHandler *_conn_handler;
};

#endif